# README #

In order to understand the instructions and comprehend the source code of the workloads and classes that add new functionalities to
the YCSB workload, it is necessary to have a previous understanding of the YCSB framework. Therefore, it is mandatory to study the
YCSB framework documentation (https://github.com/brianfrankcooper/YCSB/wiki) before using the workloads in this repository.

### Incrementing Key Workload ###

The IncrementingKey workload stores in the database a document that simulates the registry of a user. The primary key
of the user document is an integer value generated by a counter. Therefore, in order to store a user document, two requests are 
submitted to the database: 
* the first one increments the counter and retrieves its value;
* the second one inserts the user document with the current counter value as primary key. 

The load phase ("doInsert" method) of the workload stores the counter in the database, therefore it must be executed before the
run ("doTransaction" method) phase. If the counter is stored in a different cluster than the one that stores the users documents,
the "incrementingKey.remoteCounter" property must be set to true and the "nodes.cluster2" property must be set with the nodes that
compose the cluster in which the counter is stored.

The resultant metrics of the load phase are associated to the tags "INSERT-COUNTER" and "INSERT-COUNTER-FAILED" for successful and
failed transactions respectively. For the run phase, the tag "USER-REGISTRATION" corresponds to a successful transaction, and the
tags "INCREMENT-COUNTER-FAILED" and "USER-REGISTRATION-FAILED" correspond to failed transactions.

Currently, the IncrementingKey workload is implemented only for Couchbase 4.X (class workload.couchbase.IncrementingKey).

### UUID Key Workload ###

The UUIDKey workload stores in the database a document that simulates the registry of a user. Differently from the Incrementing
Key, the UUID Key workload uses an UUID generated by the workload class itself (the application) as the document primary key. Thus,
there is no need to execute the load phase ("doInsert" method) before the run phase ("doTransaction" method) in order to prepare the
database.  

The resultant metrics of a successful transaction are associated to the tag "USER-REGISTRATION", while metrics for failed
transactions are associated to the tag "USER-REGISTRATION-FAILED". 

Currently, the UUID Key workload  is implemented only for Couchbase 4.X (class workload.couchbase.UuidKey).

### Secondary Index Workloads ###

The SecondaryIndexInsertUser workload stores in the database a record that simulates a user registry. The user record has an email
field that must be indexed in the database in order to test the database performance with an approach based on a secondary index.

The email field of a user record is populated with the current value of a counter after applying it as the input of a hash function
and converting the result to a string of characters. That operation is executed by the workload class (at the application side). For
instance, if the SecondaryIndexInsertUser workload is execute 5 times by the YCSB client, with the property
"secondaryIndex.counterStart" set to 1, it will insert 5 user records in the database, and their email values will be populated with
the values 1, 2, 3, 4 and 5 after applying the hash function. That means that, the values of the email fields of the user records
would be respectively, "8517097267634966620", "1820151046732198393", "4052466453699787802", "3232700585171816769" and
"1000385178204227360".

That strategy creates random email values but it also allows the SecondaryIndexQueryUser workload to know in advance the values of
the users records email fields so it can query them in another moment. The SecondaryIndexQueryUser workload requests a user record
using its email as search key. If the SecondaryIndexQueryUser run phase must be executed multiple times, the 
"secondaryIndex.counterStart" property defines the starting point for querying the users. The workload applies the same hash
function applied by the SecondaryIndexInsertUser workload, so it can query the same users inserted previously in the database.
Despite the email values are generated deterministically, the hash function inserts randomness avoiding them to be stored contiguously
in the database index table. The algorithm for generating the hash code is a 32 bits FNV hash 
(from http://en.wikipedia.org/wiki/Fowler_Noll_Vo_hash). It is implemented by the class com.yahoo.ycsb.Utils, from the YCSB API.

The SecondaryIndexInsertUser and SecondaryIndexQueryUser workloads have only the run phase ("doTransaction" method). That is the phase
that inserts the user record, for the SecondaryIndexInsertUser workload, and queries the user record, for the SecondaryIndexQuerytUser
workload. The resultant metrics for a successful and failed run phase for the SecondaryIndexInsertUserworkload are associated with the
tags "INSERT-USER" and "INSERT-USER-FAILED" respectively. And the resultant metrics for a successful and failed run phase for the
SecondaryIndexQueryUser are associated with the tags "QUERY-USER" and "QUERY-USER-FAILED" respectively.   

Currently, the Secondary Index workloads are implemented for Couchbase 4.X (classes workload.couchbase.SecondaryIndexInsertUser and
workload.couchbase.SecondaryIndexQueryUser), Cassandra 3.X (classes workload.cassandra.workload.SecondaryIndexInsertUser and
workload.cassandra.workload.SecondaryIndexQuerytUser), and MongoDB 3.2.X (classes workload.mongodb.workload.SecondaryIndexInsertUser
and workload.mongodb.workload.SecondaryIndexQuerytUser).

### Index Table Workloads ###

The IndexTableInsertUser and IndexTableQueryUser are the counterparts of the SecondaryIndexInsertUser and SecondaryIndexQueryUser
respectively. The IndexTableInsertUser inserts in the database a record that simulates a user registry and stores an additional
record in another table (or collection). That additional record uses the user email as primary key (consequently, shard key) and
stores the user UUID in another field of that record. Thus, the transaction of storing a user record consists of two requests: 
* one for storing the user record in the users table;
* and another for storing the lookup record in its own table.
It's important to mention that in Couchbase there is no tables or collections, the bucket is a common keyspace for all aggregates
stored in the database. The user insertion transaction is executed in the run phase ("doTransaction" method) of the
IndexTableInsertUser workload.

The IndexTableQueryUser workload retrieves a user record from the databases. However, it does not queries the user directly, as the
SecondaryIndexQueryUser workload does. Instead, the IndexTableQueryUser requests the lookup record by the user email. Once it has
the lookup record, it uses the user UUID to query the user record. The transaction of retrieving a user record consists of two stages:
* retrieving the lookup record using the user email as search key;
* and retrieving the user record using its UUID as search key. 
The user query transaction is executed in the run phase ("doTransaction" method) of the IndexTableQuerytUser workload.

For both workloads, IndexTableInsertUser and IndexTableQueryUser, the email value for the user record is generated with the approach
of the SecondaryIndex workloads. The value generated by a counter is submitted to the 32 bits FNV hash function and converted to a
string of characters. That makes possible to insert the randomness for the index but keeping a bound between the two workloads that are executed in
different moments. 

The IndexTableInsertUser and IndexTableQueryUser workloads have only the run phase ("doTransaction") method. The resultant metrics 
for a successful and failed run phase for the IndexTableInsertUser workload are associated with the
tags "INSERT-USER" and "INSERT-USER-FAILED" respectively. And the resultant metrics for a successful and failed run phase for the
IndexTableQueryUser are associated with the tags "QUERY-USER" and "QUERY-USER-FAILED" respectively.

Currently, the Index Table workloads are implemented for Couchbase 4.X (classes workload.couchbase.IndexTableInsertUser and
workload.couchbase.IndexTableQueryUser), Cassandra 3.X (classes workload.cassandra.workload.IndexTableInsertUser and
workload.cassandra.workload.IndexTableQuerytUser), and MongoDB 3.2.X (classes workload.mongodb.workload.IndexTableInsertUser
and workload.mongodb.workload.IndexTableQuerytUser).  

### LBA Workloads ###

The LbaPostComment (List Based Association) workload, in its load phase ("doInsert" method) inserts in the database a document that
simulates a blog post. In it's run phase ("doTransaction" method) the workload inserts documents that simulates comments related to
the post inserted previously in the load phase. Therefore, the load phase is mandatory and must be executed before the run phase.
Both phases of the LbaPotsComments workload depend on the property "lba.postUuid". That property determines the UUID used as primary
key of the post document.

In it's run phase, the LbaPostComment workload inserts a comment document associated (one-to-many association) to the post document.
The comment (multiples comments if the workload is executed multiple times) is store as an element of a list attribute of the post
document. That means that the post and its comments are stored as a single aggregate in the database. The comments are kept in
chronological order inside the list attribute so user of the blog could paginate the comments of a post in the correct order.

The LbaPaginateComments workload retrieves from the database 10 comment documents associated with the post document designated by the
"lba.postUuid" property. Each time the LbaPaginateComments workload run phase ("doTransaction" method) is executed (the multiple 
executions must be in the same test cycle, consult the YCSB documentation for more information) by a thread, it updates the index of 
the next comment. For instance, the LbaPaginateComments workload run phase is executed 100 times by 10 threads. According to the YCSB
implementation, each thread will execute the "doTransaction" method 10 times. However a thread is not going to retrieve the same 10
comment documents in each iteration. The thread paginates the comments by retrieve the next 10 comments each time is executes the
"doTransaction" method. Additionally, each thread will start the pagination from a different initial comment index. During the
initialization of each thread the index of the first comment is sorted so the threads paginate through different subsets of comments,
as multiple users would do.

The property "lba.pagination.lastCommentIndex" must be set for the LbaPaginateComments workload since it informs the index of the
last comment associated to the post. The threads need that information in order to restart pagination if they reach the last comment.
Only the LbaPostComment workload has a load phase and it must be executed before its run phase. The LbaPostComment workload must be
executed before the LbaPaginateComments workload in order to populate the database with the post document and its embedded comment
documents.

For the LbaPostComment workload, the tag "INSERT-POST" indicates a successful load phase and the "INSERT-POST-FAILED" tag indicates
that a failure happened. For the run phase of the same workload, the "INSERT-COMMENT" tag indicates that the comment documents was
successfully stored, and the tag "INSERT-COMMENT-FAILED" indicates that the transaction failed.

For the LbaPaginateComment workload, the tag "QUERY-COMMENTS" gathers the metrics for a successful transaction, while the tag
"QUERY-COMMENTS-FAILED" is associated to metrics of failed transaction. 

Currently, the LBA workloads are implemented for Couchbase 4.X (classes workload.couchbase.LbaPostComment and
workload.couchbase.LbaPaginateComments), and MongoDB 3.2.X (classes workload.mongodb.workload.LbaPostComment
and workload.mongodb.workload.LbaPaginateComments).

### Enumerable Keys Workloads ###

The Enumerable Keys workloads are the counterparts of the LBA workloads. Instead of storing the comments of a post as elements of a
list attribute of the post document, the post and its comments are not stored as a single aggregate. The primary key of a comment
indicates the post it belongs to and indicates its position among the comments of the post, keeping the comments chronological order.
The primary key of a comment document is a concatenation between the primary key (a UUID) of the post the comment belongs to and
the current value of a counter that tracks the number of comments a post has.

The load phase ("doInsert" method) of the EnumerableKeysPostComment workload inserts the post document in the database. The property
"enumerableKeys.postUuid" must be set so the workload can determine the primary key of the post document. That phase is mandatory and
must be executed before the run phase ("doTransaction" method). The run phase ("doInsert" method) stores in the database a comment
document associated to the post indicated by the "enumerableKeys.postUuid" property. The transaction of storing the a comment consists
in two request to the database:
* the first one increments the comments counter of the post document and retrieves its new value;
* and the second one stored the comment document using the value retrieved from the counter to produce the document primary key.

The EnumerableKeysPaginateComments has no load phase ("doInsert" method). However, it depends on the post and comment documents
stored in the database by previous execution(s) of the EnumerableKeysPostComment workload. The "enumerableKeys" property must be set
to the same value used in for the EumerableKeysPostComment workload. The EnumerableKeysPaginateComments paginates the comments of a
post document by retrieving 10 comment documents in each iteration. It works like the LbaPaginateComments workload. Multiple threads
can paginate through the comments of a post and each thread will start from a randomicaly sorted initial comment index. The property
"enumerableKeys.pagination.commentCount" must be set so a thread can restart the pagination if it reaches the last comment.

For the EnumerableKeysPostComment workload, the tags "INSERT-POST" and "INSERT-POST-FAILED" indicates a successful and failed load
phase. The resultant metrics of a successful run phase are associated to the tag "INSERT-COMMENT", and the metrics of a failed run
phase are associated to the tag "INSERT-POST-FAILED".

For the EnumerableKeysPaginateComments workload, the tag "QUERY-COMMENTS" is associated with the metrics of a successful run phase,
and the tag "QUERY-COMMENTS-FAILED" is associated with the metrics of a failed run phase.

Currently, the Enumerable Keys workloads are implemented for Couchbase 4.X (classes workload.couchbase.EnumerableKeysPostComment and
workload.couchbase.EumerableKeysPaginateComments), and MongoDB 3.2.X (classes workload.mongodb.workload.EnumerableKeysPostComment
and workload.mongodb.workload.EumerableKeysPaginateComments).

### Fan-out on Read Workloads ###

The Fan-out on Read Workloads simulates a near real-time event stream application type, the feed system of a social network. The
workloads accepts as inputs the number of users ("for.usersCount" property), the number of friends a user has ("for.friendsPerUser"
property) and the number of activities each user has published ("for.activitiesPerUser property"). Those parameters are mandatory and
must be informed for both workloads (ForSaveActivity and ForPaginateFeeds).

The ForSaveActivity workload saves the associations between users and their friends during its load phase ("doInsert" method). Each
time the load phase is executed it stores all the friend associations for the current user. For instance, if the property
"for.friendsPerUser" has the value 100, the "doInsert" method will store 100 records that associate friends to the current user.
If the property "for.usersCount" has the value 1000, the load phase must be executed 1000 times, consequently the recordcount
parameter informed to the YCSB client must be 1000 too. Thus, in each one of its 1000 executions the load phase will store 100 friends
associations to the current user. The set of friends associated to each user changes between the iterations of the load phase in order
to distributed the friendship associations among the users as equally as possible.

After executing the load phase, the run phase ("doTransaction" method) of the ForSaveActivity workload can be executed in order to
store in the database the activities posted by each user. Each time the run phase is executed it stores an activity for a different
user in the database and the generated activity has a date and time field with a value one second ahead of the previous generated
activity record. For instance, if the value of the "for.usersCount" property is 1000 and the value of the "for.activitiesPerUser" is
100, in order to distribute 100 activities to each user the run phase must be executed 1000 * 100 times. For each execution the
activity is stored for a different user until all the 100000 activities are equally distributed among the 1000 users.

The ForPaginateFeeds workload simulates a user paginating his/her news feed. Each time a thread executes the run phase
("doTransaction" method) it retrieves a specific number of activities posted by friends of the current user as it would display a
page of the news feed. The property "for.friendsPerPage" determines the quantity of friends that will have his/her activities
displayed in the current page and the "for.friendsActivitiesPerPage" property determines the number of activities of a friend that
can be displayed in a page. Therefore, the number of activities retrieve in order to mount a news feed page is the number of friends
per page multiplied by the number of activities of a friend in a page (for.friendsPerPage * for.friendsActivitiesPerPage). For
instance if the value of the "for.friendsPerPage" is 10 and the value of the "for.friendsActivitiesPerPage" activity is 2, each query
to retrieve the activities in order to mount a news feed page will retrieve 20 activities. 

In the next iteration of a thread that executes the run phase of the ForPaginateFeeds workload, the thread will choose a different
user and will retrieve the activities of friends of the current user. When a user is chosen again by some thread, the pagination of
his/her news feed resumes from the point it was interrupted in the previous iteration. If in the previous iteration for the current
user the activities of the 10 first friends were retrieve, this time the next 10 friends will have its activities retrieved from the
database. That cycles goes on until the all the friends of a user are paginated. At that point the friends pagination for the current
user is restarted, however, the next activity in the friends timeline is displayed. That makes possible to paginate through the
activities of the friends of a user showing the activities by some chronological order.

For the ForPaginateFeeds and ForSaveActivity workloads, the news feed of users is mounted at read time. The run phase of the
ForPaginateFeeds workload executes a transaction composed by multiple queries, actually the value of the "for.friendsPerPage"
property.  The number of times the run phase of the ForPaginateFeeds workload must be executed in order to paginate all activities of
all friends of all the users is indicated by the formula:

* for.usersCount * (for.friendsPerUser * for.activitiesPerUser) / (for.friendsPerPage * for.friendsActivitiesPerPage)

For the ForSaveActivity workload, the tag associated with metrics of successful transactions of the load phase is "SAVE-FRIEND" and
for failed transactions is "SAVE-FRIEND-FAILED".  For the run phase, the tag associated with metrics of a successful transaction is
"SAVE-ACTIVITY", and for failed transactions is "SAVE-ACTIVITY-FAILED".

For the ForPaginateFeeds workload, the tag associated with metrics of a successful transaction of the run phase is "PAGINATE-FEED"
and for failed transactions is "PAGINATE-FEED-FAILED".

Currently, the Fan-out on Read workloads are implemented only for Cassandra 3.X (classes workload.cassandra.ForSaveActivity and
workload.cassandra.ForPaginateFeeds).

### Fan-out on Write Workloads ###

The Fan-out on Write workloads are the counterparts of the Fan-out on Read workloads. Instead of mounting a user news feed page by
submitting several read request to the database at read time, the news feed of a user is stored in advance by fanning-out the
activities of a user to all his/her followers at write time. 

The FowSaveActivity workload also has a load phase ("doInsert" method). However that load phase is just a convenience since it is
equal to the load phase of the ForSaveActivity workload, its objective is to store the user and its friends in order to populate the
database for the run phase ("doInsert" method).

The run phase of the FowSaveActivity workload is accepts the properties "fow.usersCount", "fow.friendsPerUser", and
"fow.activitiesPerUser" as input parameters. Each time the run phase is executed by a thread, an activity is stored for the current
user and the same activity is store again in the feeds table, one record for each follower of the current user. For instance, if
each user has 100 friends the transaction of the run phase consists in storing the activity for the current user and storing the same
activity 100 times in the feeds table using the id of the friend as shard key. Each time a thread executes the "doInsert" method, a
random user is selected to have its activity stored and fanned-out. If the simulated system has 1000 users and each user has posted
10 activities, the run phase must be executed 10000 times in order to store all the activities for all users.

The run phase of the FowPaginteFeeds workload mounts the current page for the current user by just retrieving from the database with a
single request the activities that must be displayed that are already stored in the feeds table. Each thread chooses a user therefore
multiple thread can paginate users feeds at the same time. However, when a user is selected for again by any thread the next
activities to be displayed are retrieving from the database by the chronological order. The formula for paginating all activities of
users friends is:

* fow.usersCount * fow.friendsPerUser * fow.activitiesPerUser / fow.activitiesPerPage

For the FowSaveActivity workload, the tag associated with metrics of successful transactions of the load phase is "SAVE-FRIEND" and
for failed transactions is "SAVE-FRIEND-FAILED".  For the run phase, the tag associated with metrics of a successful transaction is
"SAVE-ACTIVITY", and for failed transactions is "SAVE-ACTIVITY-FAILED".

For the FowPaginateFeeds workload, the tag associated with metrics of a successful transaction of the run phase is "PAGINATE-FEED"
and for failed transactions is "PAGINATE-FEED-FAILED".

Currently, the Fan-out on Write workloads are implemented only for Cassandra 3.X (classes workload.cassandra.FowSaveActivity and
workload.cassandra.FowPaginateFeeds). The Fan-out on Read and Fan-out on Write workloads are addressed to column-family NoSQL
databases since it relies on the capacity of clustering in the same shard records that share the same shard key value.


  





 